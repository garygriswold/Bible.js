/**
* This program validates that the HTML copy of the Bible that is generated by the Publisher program,
* contains exactly the same text as the original USX files.  The verses table was generated from the USX
* files by Library/manuacture/VersesBuilder.js  It did this by reading the USX files using the USXParser,
* This program reads the HTML files in the version.db Chapters table, and extracting the text.  
* It outputs both of these to a text file of the entire Bible, and does a line by 
* line comparison using diff.  
* In order to be able to do line by line comparison it outputs each verse as a line.
*/
function VersesValidator(versionPath) {
	this.versionPath = versionPath;
	this.fs = require('fs');
	this.db = null;
	var canon = new Canon();
	this.bookMap = canon.sequenceMap();
	Object.seal(this);
}
VersesValidator.prototype.open = function(callback) {
	var that = this;
	var sqlite3 = require('sqlite3');
	this.db = new sqlite3.Database(this.versionPath, sqlite3.OPEN_READWRITE, function(err) {
		if (err) that.fatalError(err, 'openDatabase');
		//that.db.on('trace', function(sql) { console.log('DO ', sql); });
		//that.db.on('profile', function(sql, ms) { console.log(ms, 'DONE', sql); });
		callback();
	});
};
VersesValidator.prototype.generateChaptersFile = function(callback) {
	var that = this;
	var bible = [];
	var chapter = [];
	var verse = [];
	var statement = 'SELECT reference, html FROM chapters';
	this.db.all(statement, [], function(err, results) {
		if (err) {
			that.fatalError(err, 'generateChaptersFile');
		} else {
			for (var i=1; i<results.length; i++) {
				var row = results[i];
				parseChapter(row.reference, row.html);
			}
			that.fs.writeFileSync('output/chapters.txt', bible.join(''), "utf8");
		}
	});
	
	function parseChapter(reference, html) {
		var reader = new XMLTokenizer(html);
		var elementStack = [];
		var element = null;
		var attrName = null;
		var verseId = null;
		while (tokenType !== XMLNodeType.END) {
			var tokenType = reader.nextToken();
			var tokenValue = reader.tokenValue();
			
			switch(tokenType) {
				case XMLNodeType.ELE_OPEN:
					element = { tagName: tokenValue };
					break;
				case XMLNodeType.ATTR_NAME:
					attrName = tokenValue;
					break;
				case XMLNodeType.ATTR_VALUE:
					element[attrName] = tokenValue;
					if (attrName === 'class' && tokenValue === 'v') {
						outputVerse(verseId);
						verseId = element['id'];
					}
					break;
				case XMLNodeType.ELE_END:
					elementStack.push(element);
					break;
				case XMLNodeType.ELE_EMPTY:
					// do nothing,
					break;
				case XMLNodeType.WHITESP:
				case XMLNodeType.TEXT:
					var currElement = elementStack[elementStack.length -1];
					switch(currElement.tagName) {
						case 'section':
							verse.push(tokenValue);
							break;
						case 'p':
							verse.push(tokenValue);
							break;
						case 'span':
							var clas = currElement['class'];
							if (clas !== 'v' && ! isAncestorFootnote(elementStack)) {
								verse.push(tokenValue);
							}
							break;
					}
					break;
				case XMLNodeType.ELE_CLOSE:
					element = elementStack.pop();
					break;
				case XMLNodeType.PROG_INST:
					// do nothing
					break;
				case XMLNodeType.END:
					outputVerse(verseId);
					break;
				default:
					throw new Error('The XMLNodeType ' + tokenType + ' is unknown in VersesValidator.');
			}
		}
		outputVerse(reference);
		outputChapter();
	}
	function isAncestorFootnote(stack) {
		for (var i=0; i<stack.length; i++) {
			var clas = stack[i]['class'];
			if (clas === 'topf' || clas === 'topx') {
				return(true);
			}
		}
		return(false);
	}
	function outputVerse(verseId) {
		//console.log('OUTPUT VERSE ***', verse.join(''));
		if (verse.length > 0 && verseId) {
			chapter.push(verseId, '|', verse.join('').trim(), '\n');
		}
		verse = [];
	}
	function outputChapter() {
		//console.log('OUTPUT CHAPTER ****', chapter.join(''));
		if (chapter.length > 0) {
			bible.push(chapter.join(''));
		}
		chapter = [];
	}	
};
VersesValidator.prototype.fatalError = function(err, source) {
	console.log('FATAL ERROR ', err, ' AT ', source);
	process.exit(1);
};
VersesValidator.prototype.completed = function() {
	console.log('HTML VALIDATOR COMPLETED');
	this.db.close();
	process.exit(0);
};


var DB_PATH = '../../DBL/3prepared/';
	
if (process.argv.length < 3) {
	console.log('Usage: ./HTMLValidator.sh VERSION');
	process.exit(1);
} else {
	var dbFilename = DB_PATH + process.argv[2] + '.db';
	console.log('Process ' + dbFilename);
	var val = new VersesValidator(dbFilename);
	val.open(function() {
		val.generateChaptersFile(function() {
			val.completed();
		});
	});
}

